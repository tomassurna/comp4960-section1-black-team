{"ast":null,"code":"/*!\nFullCalendar Scheduler v5.3.2\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2020 Adam Shaw\n*/\nimport { Emitter, DelayedRunner, removeElement, computeEdges, findElements, translateRect, computeInnerRect, applyStyle, createRef, getScrollbarWidths, setRef, getIsRtlScrollbarOnLeft, createElement, Scroller, isPropsEqual, BaseComponent, memoizeArraylike, renderMicroColGroup, RefMap, memoizeHashlike, getScrollGridClassNames, getCanVGrowWithinCell, Fragment, getSectionClassNames, getAllowYScrolling, getSectionHasLiquidHeight, renderChunkContent, computeShrinkWidth, collectFromHash, mapHash, isArraysEqual, sanitizeShrinkWidth, hasShrinkWidth, compareObjs, isColPropsEqual, createPlugin } from '@fullcalendar/common';\nimport premiumCommonPlugin from '@fullcalendar/premium-common';\nimport { __extends, __assign, __spreadArrays } from 'tslib';\nvar WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ');\n/*\nALSO, with the ability to disable touch\n*/\n\nvar ScrollListener =\n/** @class */\nfunction () {\n  function ScrollListener(el) {\n    var _this = this;\n\n    this.el = el;\n    this.emitter = new Emitter();\n    this.isScrolling = false;\n    this.isTouching = false; // user currently has finger down?\n\n    this.isRecentlyWheeled = false;\n    this.isRecentlyScrolled = false;\n    this.wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this));\n    this.scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this)); // Handlers\n    // ----------------------------------------------------------------------------------------------\n\n    this.handleScroll = function () {\n      _this.startScroll();\n\n      _this.emitter.trigger('scroll', _this.isRecentlyWheeled, _this.isTouching);\n\n      _this.isRecentlyScrolled = true;\n\n      _this.scrollWaiter.request(500);\n    }; // will fire *before* the scroll event is fired (might not cause a scroll)\n\n\n    this.handleWheel = function () {\n      _this.isRecentlyWheeled = true;\n\n      _this.wheelWaiter.request(500);\n    }; // will fire *before* the scroll event is fired (might not cause a scroll)\n\n\n    this.handleTouchStart = function () {\n      _this.isTouching = true;\n    };\n\n    this.handleTouchEnd = function () {\n      _this.isTouching = false; // if the user ended their touch, and the scroll area wasn't moving,\n      // we consider this to be the end of the scroll.\n\n      if (!_this.isRecentlyScrolled) {\n        _this.endScroll(); // won't fire if already ended\n\n      }\n    };\n\n    el.addEventListener('scroll', this.handleScroll);\n    el.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.addEventListener('touchend', this.handleTouchEnd);\n\n    for (var _i = 0, WHEEL_EVENT_NAMES_1 = WHEEL_EVENT_NAMES; _i < WHEEL_EVENT_NAMES_1.length; _i++) {\n      var eventName = WHEEL_EVENT_NAMES_1[_i];\n      el.addEventListener(eventName, this.handleWheel);\n    }\n  }\n\n  ScrollListener.prototype.destroy = function () {\n    var el = this.el;\n    el.removeEventListener('scroll', this.handleScroll);\n    el.removeEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    el.removeEventListener('touchend', this.handleTouchEnd);\n\n    for (var _i = 0, WHEEL_EVENT_NAMES_2 = WHEEL_EVENT_NAMES; _i < WHEEL_EVENT_NAMES_2.length; _i++) {\n      var eventName = WHEEL_EVENT_NAMES_2[_i];\n      el.removeEventListener(eventName, this.handleWheel);\n    }\n  }; // Start / Stop\n  // ----------------------------------------------------------------------------------------------\n\n\n  ScrollListener.prototype.startScroll = function () {\n    if (!this.isScrolling) {\n      this.isScrolling = true;\n      this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching);\n    }\n  };\n\n  ScrollListener.prototype.endScroll = function () {\n    if (this.isScrolling) {\n      this.emitter.trigger('scrollEnd');\n      this.isScrolling = false;\n      this.isRecentlyScrolled = true;\n      this.isRecentlyWheeled = false;\n      this.scrollWaiter.clear();\n      this.wheelWaiter.clear();\n    }\n  };\n\n  ScrollListener.prototype._handleScrollWaited = function () {\n    this.isRecentlyScrolled = false; // only end the scroll if not currently touching.\n    // if touching, the scrolling will end later, on touchend.\n\n    if (!this.isTouching) {\n      this.endScroll(); // won't fire if already ended\n    }\n  };\n\n  ScrollListener.prototype._handleWheelWaited = function () {\n    this.isRecentlyWheeled = false;\n  };\n\n  return ScrollListener;\n}(); // TODO: assume the el has no borders?\n\n\nfunction getScrollCanvasOrigin(scrollEl) {\n  var rect = scrollEl.getBoundingClientRect();\n  var edges = computeEdges(scrollEl); // TODO: pass in isRtl?\n\n  return {\n    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n    top: rect.top + edges.borderTop - scrollEl.scrollTop\n  };\n}\n\nfunction getScrollFromLeftEdge(el) {\n  var val = el.scrollLeft;\n  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'negative':\n        val = el.scrollWidth - el.clientWidth + val; // maxScrollDistance + val\n\n        break;\n\n      case 'reverse':\n        val = el.scrollWidth - el.clientWidth - val; // maxScrollDistance - val\n\n        break;\n    }\n  }\n\n  return val;\n}\n/*\n`val` is in the \"negative\" scheme\n*/\n\n\nfunction setScrollFromStartingEdge(el, val) {\n  var computedStyles = window.getComputedStyle(el); // TODO: pass in isRtl?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'positive':\n        val = el.scrollWidth - el.clientWidth + val; // maxScrollDistance + val\n\n        break;\n\n      case 'reverse':\n        val = -val;\n        break;\n    }\n  }\n\n  el.scrollLeft = val;\n} // Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\n\n\nvar _rtlScrollSystem;\n\nfunction getRtlScrollSystem() {\n  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n}\n\nfunction detectRtlScrollSystem() {\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '-1000px';\n  el.style.width = '1px';\n  el.style.height = '1px';\n  el.style.overflow = 'scroll';\n  el.style.direction = 'rtl';\n  el.style.fontSize = '100px';\n  el.innerHTML = 'A';\n  document.body.appendChild(el);\n  var system;\n\n  if (el.scrollLeft > 0) {\n    system = 'positive'; // scroll is a positive number from the left edge\n  } else {\n    el.scrollLeft = 1;\n\n    if (el.scrollLeft > 0) {\n      system = 'reverse'; // scroll is a positive number from the right edge\n    } else {\n      system = 'negative'; // scroll is a negative number from the right edge\n    }\n  }\n\n  removeElement(el);\n  return system;\n}\n\nvar IS_MS_EDGE = /Edge/.test(navigator.userAgent); // TODO: what about Chromeum-based Edge?\n\nvar STICKY_SELECTOR = '.fc-sticky';\n/*\nuseful beyond the native position:sticky for these reasons:\n- support in IE11\n- nice centering support\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\n\nvar StickyScrolling =\n/** @class */\nfunction () {\n  function StickyScrolling(scrollEl, isRtl) {\n    var _this = this;\n\n    this.scrollEl = scrollEl;\n    this.isRtl = isRtl;\n    this.usingRelative = null;\n\n    this.updateSize = function () {\n      var scrollEl = _this.scrollEl;\n      var els = findElements(scrollEl, STICKY_SELECTOR);\n\n      var elGeoms = _this.queryElGeoms(els);\n\n      var viewportWidth = scrollEl.clientWidth;\n      var viewportHeight = scrollEl.clientHeight;\n\n      if (_this.usingRelative) {\n        var elDestinations = _this.computeElDestinations(elGeoms, viewportWidth); // read before prepPositioning\n\n\n        assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight);\n      } else {\n        assignStickyPositions(els, elGeoms, viewportWidth);\n      }\n    };\n\n    this.usingRelative = !computeStickyPropVal() || // IE11\n    // https://stackoverflow.com/questions/56835658/in-microsoft-edge-sticky-positioning-doesnt-work-when-combined-with-dir-rtl\n    IS_MS_EDGE && isRtl;\n\n    if (this.usingRelative) {\n      this.listener = new ScrollListener(scrollEl);\n      this.listener.emitter.on('scrollEnd', this.updateSize);\n    }\n  }\n\n  StickyScrolling.prototype.destroy = function () {\n    if (this.listener) {\n      this.listener.destroy();\n    }\n  };\n\n  StickyScrolling.prototype.queryElGeoms = function (els) {\n    var _a = this,\n        scrollEl = _a.scrollEl,\n        isRtl = _a.isRtl;\n\n    var canvasOrigin = getScrollCanvasOrigin(scrollEl);\n    var elGeoms = [];\n\n    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n      var el = els_1[_i];\n      var parentBound = translateRect(computeInnerRect(el.parentNode, true, true), // weird way to call this!!!\n      -canvasOrigin.left, -canvasOrigin.top);\n      var elRect = el.getBoundingClientRect();\n      var computedStyles = window.getComputedStyle(el);\n      var textAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n\n      var naturalBound = null;\n\n      if (textAlign === 'start') {\n        textAlign = isRtl ? 'right' : 'left';\n      } else if (textAlign === 'end') {\n        textAlign = isRtl ? 'left' : 'right';\n      }\n\n      if (computedStyles.position !== 'sticky') {\n        naturalBound = translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n        -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n      }\n\n      elGeoms.push({\n        parentBound: parentBound,\n        naturalBound: naturalBound,\n        elWidth: elRect.width,\n        elHeight: elRect.height,\n        textAlign: textAlign\n      });\n    }\n\n    return elGeoms;\n  }; // only for IE\n\n\n  StickyScrolling.prototype.computeElDestinations = function (elGeoms, viewportWidth) {\n    var scrollEl = this.scrollEl;\n    var viewportTop = scrollEl.scrollTop;\n    var viewportLeft = getScrollFromLeftEdge(scrollEl);\n    var viewportRight = viewportLeft + viewportWidth;\n    return elGeoms.map(function (elGeom) {\n      var elWidth = elGeom.elWidth,\n          elHeight = elGeom.elHeight,\n          parentBound = elGeom.parentBound,\n          naturalBound = elGeom.naturalBound;\n      var destLeft; // relative to canvas topleft\n\n      var destTop; // \"\n\n      switch (elGeom.textAlign) {\n        case 'left':\n          destLeft = viewportLeft;\n          break;\n\n        case 'right':\n          destLeft = viewportRight - elWidth;\n          break;\n\n        case 'center':\n          destLeft = (viewportLeft + viewportRight) / 2 - elWidth / 2; /// noooo, use half-width insteadddddddd\n\n          break;\n      }\n\n      destLeft = Math.min(destLeft, parentBound.right - elWidth);\n      destLeft = Math.max(destLeft, parentBound.left);\n      destTop = viewportTop;\n      destTop = Math.min(destTop, parentBound.bottom - elHeight);\n      destTop = Math.max(destTop, naturalBound.top); // better to use natural top for upper bound\n\n      return {\n        left: destLeft,\n        top: destTop\n      };\n    });\n  };\n\n  return StickyScrolling;\n}();\n\nfunction assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight) {\n  els.forEach(function (el, i) {\n    var _a = elGeoms[i],\n        naturalBound = _a.naturalBound,\n        parentBound = _a.parentBound;\n    var parentWidth = parentBound.right - parentBound.left;\n    var parentHeight = parentBound.bottom - parentBound.bottom;\n    var left;\n    var top;\n\n    if (parentWidth > viewportWidth || parentHeight > viewportHeight) {\n      left = elDestinations[i].left - naturalBound.left;\n      top = elDestinations[i].top - naturalBound.top;\n    } else {\n      // if parent container can be completely in view, we don't need stickiness\n      left = '';\n      top = '';\n    }\n\n    applyStyle(el, {\n      position: 'relative',\n      left: left,\n      right: -left,\n      top: top\n    });\n  });\n}\n\nfunction assignStickyPositions(els, elGeoms, viewportWidth) {\n  els.forEach(function (el, i) {\n    var _a = elGeoms[i],\n        textAlign = _a.textAlign,\n        elWidth = _a.elWidth,\n        parentBound = _a.parentBound;\n    var parentWidth = parentBound.right - parentBound.left;\n    var left;\n\n    if (textAlign === 'center' && parentWidth > viewportWidth) {\n      left = (viewportWidth - elWidth) / 2;\n    } else {\n      // if parent container can be completely in view, we don't need stickiness\n      left = '';\n    }\n\n    applyStyle(el, {\n      left: left,\n      right: left,\n      top: 0\n    });\n  });\n} // overkill now that we use the stylesheet to set it!\n// just test that the 'position' value of a div with the fc-sticky classname has the word 'sticky' in it\n\n\nfunction computeStickyPropVal() {\n  var el = document.createElement('div');\n  el.className = 'fc-sticky';\n  document.body.appendChild(el);\n  var val = window.getComputedStyle(el).position;\n  removeElement(el);\n\n  if (val.indexOf('sticky') !== -1) {\n    return val;\n  }\n\n  return null;\n}\n\nvar ClippedScroller =\n/** @class */\nfunction (_super) {\n  __extends(ClippedScroller, _super);\n\n  function ClippedScroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = createRef();\n    _this.state = {\n      xScrollbarWidth: getScrollbarWidths().x,\n      yScrollbarWidth: getScrollbarWidths().y\n    };\n\n    _this.handleScroller = function (scroller) {\n      _this.scroller = scroller;\n      setRef(_this.props.scrollerRef, scroller);\n    };\n\n    _this.handleSizing = function () {\n      var props = _this.props;\n\n      if (props.overflowY === 'scroll-hidden') {\n        _this.setState({\n          yScrollbarWidth: _this.scroller.getYScrollbarWidth()\n        });\n      }\n\n      if (props.overflowX === 'scroll-hidden') {\n        _this.setState({\n          xScrollbarWidth: _this.scroller.getXScrollbarWidth()\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  ClippedScroller.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft();\n    var overcomeLeft = 0;\n    var overcomeRight = 0;\n    var overcomeBottom = 0;\n\n    if (props.overflowX === 'scroll-hidden') {\n      overcomeBottom = state.xScrollbarWidth;\n    }\n\n    if (props.overflowY === 'scroll-hidden') {\n      if (state.yScrollbarWidth != null) {\n        if (isScrollbarOnLeft) {\n          overcomeLeft = state.yScrollbarWidth;\n        } else {\n          overcomeRight = state.yScrollbarWidth;\n        }\n      }\n    }\n\n    return createElement(\"div\", {\n      ref: this.elRef,\n      className: 'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')\n    }, createElement(Scroller, {\n      ref: this.handleScroller,\n      elRef: this.props.scrollerElRef,\n      overflowX: props.overflowX === 'scroll-hidden' ? 'scroll' : props.overflowX,\n      overflowY: props.overflowY === 'scroll-hidden' ? 'scroll' : props.overflowY,\n      overcomeLeft: overcomeLeft,\n      overcomeRight: overcomeRight,\n      overcomeBottom: overcomeBottom,\n      maxHeight: typeof props.maxHeight === 'number' ? props.maxHeight + (props.overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0) : '',\n      liquid: props.liquid,\n      liquidIsAbsolute: true\n    }, props.children));\n  };\n\n  ClippedScroller.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  ClippedScroller.prototype.componentDidUpdate = function (prevProps) {\n    if (!isPropsEqual(prevProps, this.props)) {\n      // an external change?\n      this.handleSizing();\n    }\n  };\n\n  ClippedScroller.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  ClippedScroller.prototype.needsXScrolling = function () {\n    return this.scroller.needsXScrolling();\n  };\n\n  ClippedScroller.prototype.needsYScrolling = function () {\n    return this.scroller.needsYScrolling();\n  };\n\n  return ClippedScroller;\n}(BaseComponent);\n\nvar ScrollSyncer =\n/** @class */\nfunction () {\n  function ScrollSyncer(isVertical, scrollEls) {\n    var _this = this;\n\n    this.isVertical = isVertical;\n    this.scrollEls = scrollEls;\n    this.isPaused = false;\n    this.scrollListeners = scrollEls.map(function (el) {\n      return _this.bindScroller(el);\n    });\n  }\n\n  ScrollSyncer.prototype.destroy = function () {\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var scrollListener = _a[_i];\n      scrollListener.destroy();\n    }\n  };\n\n  ScrollSyncer.prototype.bindScroller = function (el) {\n    var _this = this;\n\n    var _a = this,\n        scrollEls = _a.scrollEls,\n        isVertical = _a.isVertical;\n\n    var scrollListener = new ScrollListener(el);\n\n    var onScroll = function (isWheel, isTouch) {\n      if (!_this.isPaused) {\n        if (!_this.masterEl || _this.masterEl !== el && (isWheel || isTouch)) {\n          _this.assignMaster(el);\n        }\n\n        if (_this.masterEl === el) {\n          // dealing with current\n          for (var _i = 0, scrollEls_1 = scrollEls; _i < scrollEls_1.length; _i++) {\n            var otherEl = scrollEls_1[_i];\n\n            if (otherEl !== el) {\n              if (isVertical) {\n                otherEl.scrollTop = el.scrollTop;\n              } else {\n                otherEl.scrollLeft = el.scrollLeft;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    var onScrollEnd = function () {\n      if (_this.masterEl === el) {\n        _this.masterEl = null;\n      }\n    };\n\n    scrollListener.emitter.on('scroll', onScroll);\n    scrollListener.emitter.on('scrollEnd', onScrollEnd);\n    return scrollListener;\n  };\n\n  ScrollSyncer.prototype.assignMaster = function (el) {\n    this.masterEl = el;\n\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var scrollListener = _a[_i];\n\n      if (scrollListener.el !== el) {\n        scrollListener.endScroll(); // to prevent residual scrolls from reclaiming master\n      }\n    }\n  };\n  /*\n  will normalize the scrollLeft value\n  */\n\n\n  ScrollSyncer.prototype.forceScrollLeft = function (scrollLeft) {\n    this.isPaused = true;\n\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var listener = _a[_i];\n      setScrollFromStartingEdge(listener.el, scrollLeft);\n    }\n\n    this.isPaused = false;\n  };\n\n  ScrollSyncer.prototype.forceScrollTop = function (top) {\n    this.isPaused = true;\n\n    for (var _i = 0, _a = this.scrollListeners; _i < _a.length; _i++) {\n      var listener = _a[_i];\n      listener.el.scrollTop = top;\n    }\n\n    this.isPaused = false;\n  };\n\n  return ScrollSyncer;\n}();\n\nvar ScrollGrid =\n/** @class */\nfunction (_super) {\n  __extends(ScrollGrid, _super);\n\n  function ScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual);\n    _this.renderMicroColGroups = memoizeArraylike(renderMicroColGroup); // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.clippedScrollerRefs = new RefMap(); // doesn't hold non-scrolling els used just for padding\n\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.chunkElRefs = new RefMap(_this._handleChunkEl.bind(_this));\n    _this.getStickyScrolling = memoizeArraylike(initStickyScrolling, null, destroyStickyScrolling);\n    _this.getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(_this, true), null, destroyScrollSyncer);\n    _this.getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(_this, false), null, destroyScrollSyncer);\n    _this.stickyScrollings = [];\n    _this.scrollSyncersBySection = {};\n    _this.scrollSyncersByColumn = {}; // for row-height-syncing\n\n    _this.rowUnstableMap = new Map(); // no need to groom. always self-cancels\n\n    _this.rowInnerMaxHeightMap = new Map();\n    _this.anyRowHeightsChanged = false;\n    _this.state = {\n      shrinkWidths: [],\n      forceYScrollbars: false,\n      forceXScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {},\n      sectionRowMaxHeights: []\n    };\n\n    _this.handleSizing = function (isForcedResize, sectionRowMaxHeightsChanged) {\n      if (!sectionRowMaxHeightsChanged) {\n        // something else changed, probably external\n        _this.anyRowHeightsChanged = true;\n      }\n\n      var otherState = {}; // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n\n      if (isForcedResize || !sectionRowMaxHeightsChanged && !_this.rowUnstableMap.size) {\n        otherState.sectionRowMaxHeights = _this.computeSectionRowMaxHeights();\n      }\n\n      _this.setState(__assign(__assign({\n        shrinkWidths: _this.computeShrinkWidths()\n      }, _this.computeScrollerDims()), otherState), function () {\n        if (!_this.rowUnstableMap.size) {\n          _this.updateStickyScrolling(); // needs to happen AFTER final positioning committed to DOM\n\n        }\n      });\n    };\n\n    _this.handleRowHeightChange = function (rowEl, isStable) {\n      var _a = _this,\n          rowUnstableMap = _a.rowUnstableMap,\n          rowInnerMaxHeightMap = _a.rowInnerMaxHeightMap;\n\n      if (!isStable) {\n        rowUnstableMap.set(rowEl, true);\n      } else {\n        rowUnstableMap.delete(rowEl);\n        var innerMaxHeight = getRowInnerMaxHeight(rowEl);\n\n        if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n          rowInnerMaxHeightMap.set(rowEl, innerMaxHeight);\n          _this.anyRowHeightsChanged = true;\n        }\n\n        if (!rowUnstableMap.size && _this.anyRowHeightsChanged) {\n          _this.anyRowHeightsChanged = false;\n\n          _this.setState({\n            sectionRowMaxHeights: _this.computeSectionRowMaxHeights()\n          });\n        }\n      }\n    };\n\n    return _this;\n  }\n\n  ScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var shrinkWidths = state.shrinkWidths;\n    var colGroupStats = this.compileColGroupStats(props.colGroups.map(function (colGroup) {\n      return [colGroup];\n    }));\n    var microColGroupNodes = this.renderMicroColGroups(colGroupStats.map(function (stat, i) {\n      return [stat.cols, shrinkWidths[i]];\n    }));\n    var classNames = getScrollGridClassNames(props.liquid, context);\n\n    var _b = this.getDims(),\n        sectionCnt = _b[0],\n        chunksPerSection = _b[1]; // TODO: make DRY\n\n\n    var sectionConfigs = props.sections;\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights));\n      configI += 1;\n    }\n\n    var isBuggy = !getCanVGrowWithinCell(); // see NOTE in SimpleScrollGrid\n\n    return createElement('table', {\n      ref: props.elRef,\n      className: classNames.join(' ')\n    }, renderMacroColGroup(colGroupStats, shrinkWidths), Boolean(!isBuggy && headSectionNodes.length) && createElement.apply(void 0, __spreadArrays(['thead', {}], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && createElement.apply(void 0, __spreadArrays(['tbody', {}], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && createElement.apply(void 0, __spreadArrays(['tfoot', {}], footSectionNodes)), isBuggy && createElement.apply(void 0, __spreadArrays(['tbody', {}], headSectionNodes, bodySectionNodes, footSectionNodes)));\n  };\n\n  ScrollGrid.prototype.renderSection = function (sectionConfig, sectionIndex, colGroupStats, microColGroupNodes, sectionRowMaxHeights) {\n    var _this = this;\n\n    if ('outerContent' in sectionConfig) {\n      return createElement(Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return createElement(\"tr\", {\n      key: sectionConfig.key,\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, sectionConfig.chunks.map(function (chunkConfig, i) {\n      return _this.renderChunk(sectionConfig, sectionIndex, colGroupStats[i], microColGroupNodes[i], chunkConfig, i, (sectionRowMaxHeights[sectionIndex] || [])[i] || []);\n    }));\n  };\n\n  ScrollGrid.prototype.renderChunk = function (sectionConfig, sectionIndex, colGroupStat, microColGroupNode, chunkConfig, chunkIndex, rowHeights) {\n    if ('outerContent' in chunkConfig) {\n      return createElement(Fragment, {\n        key: chunkConfig.key\n      }, chunkConfig.outerContent);\n    }\n\n    var state = this.state;\n    var scrollerClientWidths = state.scrollerClientWidths,\n        scrollerClientHeights = state.scrollerClientHeights;\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var index = sectionIndex * chunksPerSection + chunkIndex;\n    var sideScrollIndex = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n    var isVScrollSide = chunkIndex === sideScrollIndex;\n    var isLastSection = sectionIndex === sectionCnt - 1;\n    var forceXScrollbars = isLastSection && state.forceXScrollbars; // NOOOO can result in `null`\n\n    var forceYScrollbars = isVScrollSide && state.forceYScrollbars; // NOOOO can result in `null`\n\n    var allowXScrolling = colGroupStat && colGroupStat.allowXScrolling; // rename?\n\n    var allowYScrolling = getAllowYScrolling(this.props, sectionConfig); // rename? do in section func?\n\n    var chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig); // do in section func?\n\n    var expandRows = sectionConfig.expandRows && chunkVGrow;\n    var tableMinWidth = colGroupStat && colGroupStat.totalColMinWidth || '';\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: tableMinWidth,\n      clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n      clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n      expandRows: expandRows,\n      syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n      rowSyncHeights: rowHeights,\n      reportRowHeightChange: this.handleRowHeightChange\n    });\n    var overflowX = forceXScrollbars ? isLastSection ? 'scroll' : 'scroll-hidden' : !allowXScrolling ? 'hidden' : isLastSection ? 'auto' : 'scroll-hidden';\n    var overflowY = forceYScrollbars ? isVScrollSide ? 'scroll' : 'scroll-hidden' : !allowYScrolling ? 'hidden' : isVScrollSide ? 'auto' : 'scroll-hidden'; // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n    // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n\n    content = createElement(ClippedScroller, {\n      ref: this.clippedScrollerRefs.createRef(index),\n      scrollerElRef: this.scrollerElRefs.createRef(index),\n      overflowX: overflowX,\n      overflowY: overflowY,\n      liquid: chunkVGrow,\n      maxHeight: sectionConfig.maxHeight\n    }, content);\n    return createElement(\"td\", {\n      key: chunkConfig.key,\n      ref: this.chunkElRefs.createRef(index)\n    }, content);\n  };\n\n  ScrollGrid.prototype.componentDidMount = function () {\n    this.updateScrollSyncers();\n    this.handleSizing(false);\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  ScrollGrid.prototype.componentDidUpdate = function (prevProps, prevState) {\n    this.updateScrollSyncers(); // TODO: need better solution when state contains non-sizing things\n\n    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights);\n  };\n\n  ScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n    this.destroyStickyScrolling();\n    this.destroyScrollSyncers();\n  };\n\n  ScrollGrid.prototype.computeShrinkWidths = function () {\n    var _this = this;\n\n    var colGroupStats = this.compileColGroupStats(this.props.colGroups.map(function (colGroup) {\n      return [colGroup];\n    }));\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var cnt = sectionCnt * chunksPerSection;\n    var shrinkWidths = [];\n    colGroupStats.forEach(function (colGroupStat, i) {\n      if (colGroupStat.hasShrinkCol) {\n        var chunkEls = _this.chunkElRefs.collect(i, cnt, chunksPerSection); // in one col\n\n\n        shrinkWidths[i] = computeShrinkWidth(chunkEls);\n      }\n    });\n    return shrinkWidths;\n  }; // has the side effect of grooming rowInnerMaxHeightMap\n  // TODO: somehow short-circuit if there are no new height changes\n\n\n  ScrollGrid.prototype.computeSectionRowMaxHeights = function () {\n    var newHeightMap = new Map();\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var sectionRowMaxHeights = [];\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      var sectionConfig = this.props.sections[sectionI];\n      var assignableHeights = []; // chunk, row\n\n      if (sectionConfig && sectionConfig.syncRowHeights) {\n        var rowHeightsByChunk = [];\n\n        for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n          var index = sectionI * chunksPerSection + chunkI;\n          var rowHeights = [];\n          var chunkEl = this.chunkElRefs.currentMap[index];\n\n          if (chunkEl) {\n            rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map(function (rowEl) {\n              var max = getRowInnerMaxHeight(rowEl);\n              newHeightMap.set(rowEl, max);\n              return max;\n            });\n          } else {\n            rowHeights = [];\n          }\n\n          rowHeightsByChunk.push(rowHeights);\n        }\n\n        var rowCnt = rowHeightsByChunk[0].length;\n        var isEqualRowCnt = true;\n\n        for (var chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n          var isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined; // can be null\n\n          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) {\n            // skip outer content\n            isEqualRowCnt = false;\n            break;\n          }\n        }\n\n        if (!isEqualRowCnt) {\n          var chunkHeightSums = [];\n\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            chunkHeightSums.push(sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length);\n          }\n\n          var maxTotalSum = Math.max.apply(Math, chunkHeightSums);\n\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            var rowInChunkCnt = rowHeightsByChunk[chunkI].length;\n            var rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt; // subtract border\n            // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n\n            var rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt); // whatever is leftover goes to the first row\n\n            var rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1);\n            var rowInChunkHeights = [];\n            var row = 0;\n\n            if (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightFirst);\n              row += 1;\n            }\n\n            while (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightOthers);\n              row += 1;\n            }\n\n            assignableHeights.push(rowInChunkHeights);\n          }\n        } else {\n          for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            assignableHeights.push([]);\n          }\n\n          for (var row = 0; row < rowCnt; row += 1) {\n            var rowHeightsAcrossChunks = [];\n\n            for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              var h = rowHeightsByChunk[chunkI][row];\n\n              if (h != null) {\n                // protect against outerContent\n                rowHeightsAcrossChunks.push(h);\n              }\n            }\n\n            var maxHeight = Math.max.apply(Math, rowHeightsAcrossChunks);\n\n            for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              assignableHeights[chunkI].push(maxHeight);\n            }\n          }\n        }\n      }\n\n      sectionRowMaxHeights.push(assignableHeights);\n    }\n\n    this.rowInnerMaxHeightMap = newHeightMap;\n    return sectionRowMaxHeights;\n  };\n\n  ScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var sideScrollI = !this.context.isRtl || getIsRtlScrollbarOnLeft() ? chunksPerSection - 1 : 0;\n    var lastSectionI = sectionCnt - 1;\n    var currentScrollers = this.clippedScrollerRefs.currentMap;\n    var scrollerEls = this.scrollerElRefs.currentMap;\n    var forceYScrollbars = false;\n    var forceXScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      // along edge\n      var index = sectionI * chunksPerSection + sideScrollI;\n      var scroller = currentScrollers[index];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n      // along last row\n      var index = lastSectionI * chunksPerSection + chunkI;\n      var scroller = currentScrollers[index];\n\n      if (scroller && scroller.needsXScrolling()) {\n        forceXScrollbars = true;\n        break;\n      }\n    }\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (var chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        var index = sectionI * chunksPerSection + chunkI;\n        var scrollerEl = scrollerEls[index];\n\n        if (scrollerEl) {\n          // TODO: weird way to get this. need harness b/c doesn't include table borders\n          var harnessEl = scrollerEl.parentNode;\n          scrollerClientWidths[index] = Math.floor(harnessEl.getBoundingClientRect().width - (chunkI === sideScrollI && forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n          : 0));\n          scrollerClientHeights[index] = Math.floor(harnessEl.getBoundingClientRect().height - (sectionI === lastSectionI && forceXScrollbars ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n          : 0));\n        }\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      forceXScrollbars: forceXScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  ScrollGrid.prototype.updateStickyScrolling = function () {\n    var isRtl = this.context.isRtl;\n    var argsByKey = this.scrollerElRefs.getAll().map(function (scrollEl) {\n      return [scrollEl, isRtl];\n    });\n    var stickyScrollings = this.getStickyScrolling(argsByKey);\n    stickyScrollings.forEach(function (stickyScrolling) {\n      return stickyScrolling.updateSize();\n    });\n    this.stickyScrollings = stickyScrollings;\n  };\n\n  ScrollGrid.prototype.destroyStickyScrolling = function () {\n    this.stickyScrollings.forEach(destroyStickyScrolling);\n  };\n\n  ScrollGrid.prototype.updateScrollSyncers = function () {\n    var _a = this.getDims(),\n        sectionCnt = _a[0],\n        chunksPerSection = _a[1];\n\n    var cnt = sectionCnt * chunksPerSection;\n    var scrollElsBySection = {};\n    var scrollElsByColumn = {};\n    var scrollElMap = this.scrollerElRefs.currentMap;\n\n    for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      var startIndex = sectionI * chunksPerSection;\n      var endIndex = startIndex + chunksPerSection;\n      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1); // use the filtered\n    }\n\n    for (var col = 0; col < chunksPerSection; col += 1) {\n      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection); // DON'T use the filtered\n    }\n\n    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection);\n    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn);\n  };\n\n  ScrollGrid.prototype.destroyScrollSyncers = function () {\n    mapHash(this.scrollSyncersBySection, destroyScrollSyncer);\n    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer);\n  };\n\n  ScrollGrid.prototype.getChunkConfigByIndex = function (index) {\n    var chunksPerSection = this.getDims()[1];\n    var sectionI = Math.floor(index / chunksPerSection);\n    var chunkI = index % chunksPerSection;\n    var sectionConfig = this.props.sections[sectionI];\n    return sectionConfig && sectionConfig.chunks[chunkI];\n  };\n\n  ScrollGrid.prototype.forceScrollLeft = function (col, scrollLeft) {\n    var scrollSyncer = this.scrollSyncersByColumn[col];\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollLeft(scrollLeft);\n    }\n  };\n\n  ScrollGrid.prototype.forceScrollTop = function (sectionI, scrollTop) {\n    var scrollSyncer = this.scrollSyncersBySection[sectionI];\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollTop(scrollTop);\n    }\n  };\n\n  ScrollGrid.prototype._handleChunkEl = function (chunkEl, key) {\n    var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n\n    if (chunkConfig) {\n      // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.elRef, chunkEl);\n    }\n  };\n\n  ScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10));\n\n    if (chunkConfig) {\n      // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.scrollerElRef, scrollerEl);\n    }\n  };\n\n  ScrollGrid.prototype.getDims = function () {\n    var sectionCnt = this.props.sections.length;\n    var chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0;\n    return [sectionCnt, chunksPerSection];\n  };\n\n  return ScrollGrid;\n}(BaseComponent);\n\nScrollGrid.addStateEquality({\n  shrinkWidths: isArraysEqual,\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nfunction sumNumbers(numbers) {\n  var sum = 0;\n\n  for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {\n    var n = numbers_1[_i];\n    sum += n;\n  }\n\n  return sum;\n}\n\nfunction getRowInnerMaxHeight(rowEl) {\n  var innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight);\n\n  if (innerHeights.length) {\n    return Math.max.apply(Math, innerHeights);\n  }\n\n  return 0;\n}\n\nfunction getElHeight(el) {\n  return el.offsetHeight; // better to deal with integers, for rounding, for PureComponent\n}\n\nfunction renderMacroColGroup(colGroupStats, shrinkWidths) {\n  var children = colGroupStats.map(function (colGroupStat, i) {\n    var width = colGroupStat.width;\n\n    if (width === 'shrink') {\n      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1; // +1 for border :(\n    }\n\n    return (// eslint-disable-next-line react/jsx-key\n      createElement(\"col\", {\n        style: {\n          width: width\n        }\n      })\n    );\n  });\n  return createElement.apply(void 0, __spreadArrays(['colgroup', {}], children));\n}\n\nfunction compileColGroupStat(colGroupConfig) {\n  var totalColWidth = sumColProp(colGroupConfig.cols, 'width'); // excludes \"shrink\"\n\n  var totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth');\n  var hasShrinkCol = hasShrinkWidth(colGroupConfig.cols);\n  var allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol);\n  return {\n    hasShrinkCol: hasShrinkCol,\n    totalColWidth: totalColWidth,\n    totalColMinWidth: totalColMinWidth,\n    allowXScrolling: allowXScrolling,\n    cols: colGroupConfig.cols,\n    width: colGroupConfig.width\n  };\n}\n\nfunction sumColProp(cols, propName) {\n  var total = 0;\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var col = cols_1[_i];\n    var val = col[propName];\n\n    if (typeof val === 'number') {\n      total += val * (col.span || 1);\n    }\n  }\n\n  return total;\n}\n\nvar COL_GROUP_STAT_EQUALITY = {\n  cols: isColPropsEqual\n};\n\nfunction isColGroupStatsEqual(stat0, stat1) {\n  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY);\n} // for memoizers...\n\n\nfunction initScrollSyncer(isVertical) {\n  var scrollEls = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    scrollEls[_i - 1] = arguments[_i];\n  }\n\n  return new ScrollSyncer(isVertical, scrollEls);\n}\n\nfunction destroyScrollSyncer(scrollSyncer) {\n  scrollSyncer.destroy();\n}\n\nfunction initStickyScrolling(scrollEl, isRtl) {\n  return new StickyScrolling(scrollEl, isRtl);\n}\n\nfunction destroyStickyScrolling(stickyScrolling) {\n  stickyScrolling.destroy();\n}\n\nvar main = createPlugin({\n  deps: [premiumCommonPlugin],\n  scrollGridImpl: ScrollGrid\n});\nexport default main;\nexport { ScrollGrid, setScrollFromStartingEdge };","map":{"version":3,"sources":["src/ScrollListener.ts","src/scroll-left-norm.tsx","src/StickyScrolling.ts","src/ClippedScroller.tsx","src/ScrollSyncer.ts","src/ScrollGrid.tsx","src/main.ts"],"names":[],"mappings":"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","sourcesContent":["import { Emitter, DelayedRunner } from '@fullcalendar/common'\n\nconst WHEEL_EVENT_NAMES = 'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ')\n\n/*\nALSO, with the ability to disable touch\n*/\nexport class ScrollListener {\n  emitter = new Emitter()\n  private isScrolling = false\n  private isTouching = false // user currently has finger down?\n  private isRecentlyWheeled = false\n  private isRecentlyScrolled = false\n  private wheelWaiter = new DelayedRunner(this._handleWheelWaited.bind(this))\n  private scrollWaiter = new DelayedRunner(this._handleScrollWaited.bind(this))\n\n  constructor(public el: HTMLElement) {\n    el.addEventListener('scroll', this.handleScroll)\n    el.addEventListener('touchstart', this.handleTouchStart, { passive: true })\n    el.addEventListener('touchend', this.handleTouchEnd)\n\n    for (let eventName of WHEEL_EVENT_NAMES) {\n      el.addEventListener(eventName, this.handleWheel)\n    }\n  }\n\n  destroy() {\n    let { el } = this\n    el.removeEventListener('scroll', this.handleScroll)\n    el.removeEventListener('touchstart', this.handleTouchStart, { passive: true } as AddEventListenerOptions)\n    el.removeEventListener('touchend', this.handleTouchEnd)\n\n    for (let eventName of WHEEL_EVENT_NAMES) {\n      el.removeEventListener(eventName, this.handleWheel)\n    }\n  }\n\n  // Start / Stop\n  // ----------------------------------------------------------------------------------------------\n\n  private startScroll() {\n    if (!this.isScrolling) {\n      this.isScrolling = true\n      this.emitter.trigger('scrollStart', this.isRecentlyWheeled, this.isTouching)\n    }\n  }\n\n  endScroll() {\n    if (this.isScrolling) {\n      this.emitter.trigger('scrollEnd')\n      this.isScrolling = false\n      this.isRecentlyScrolled = true\n      this.isRecentlyWheeled = false\n      this.scrollWaiter.clear()\n      this.wheelWaiter.clear()\n    }\n  }\n\n  // Handlers\n  // ----------------------------------------------------------------------------------------------\n\n  handleScroll = () => {\n    this.startScroll()\n    this.emitter.trigger('scroll', this.isRecentlyWheeled, this.isTouching)\n    this.isRecentlyScrolled = true\n    this.scrollWaiter.request(500)\n  }\n\n  _handleScrollWaited() {\n    this.isRecentlyScrolled = false\n\n    // only end the scroll if not currently touching.\n    // if touching, the scrolling will end later, on touchend.\n    if (!this.isTouching) {\n      this.endScroll() // won't fire if already ended\n    }\n  }\n\n  // will fire *before* the scroll event is fired (might not cause a scroll)\n  handleWheel = () => {\n    this.isRecentlyWheeled = true\n    this.wheelWaiter.request(500)\n  }\n\n  _handleWheelWaited() {\n    this.isRecentlyWheeled = false\n  }\n\n  // will fire *before* the scroll event is fired (might not cause a scroll)\n  handleTouchStart = () => {\n    this.isTouching = true\n  }\n\n  handleTouchEnd = () => {\n    this.isTouching = false\n\n    // if the user ended their touch, and the scroll area wasn't moving,\n    // we consider this to be the end of the scroll.\n    if (!this.isRecentlyScrolled) {\n      this.endScroll() // won't fire if already ended\n    }\n  }\n}\n","import { removeElement, computeEdges } from '@fullcalendar/common'\n\n// TODO: assume the el has no borders?\nexport function getScrollCanvasOrigin(scrollEl: HTMLElement) { // best place for this?\n  let rect = scrollEl.getBoundingClientRect()\n  let edges = computeEdges(scrollEl) // TODO: pass in isRtl?\n\n  return {\n    left: rect.left + edges.borderLeft + edges.scrollbarLeft - getScrollFromLeftEdge(scrollEl),\n    top: rect.top + edges.borderTop - scrollEl.scrollTop,\n  }\n}\n\nexport function getScrollFromLeftEdge(el: HTMLElement) {\n  let val = el.scrollLeft\n  let computedStyles = window.getComputedStyle(el) // TODO: pass in isRtl?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'negative':\n        val = el.scrollWidth - el.clientWidth + val // maxScrollDistance + val\n        break\n      case 'reverse':\n        val = el.scrollWidth - el.clientWidth - val // maxScrollDistance - val\n        break\n    }\n  }\n\n  return val\n}\n\n/*\n`val` is in the \"negative\" scheme\n*/\nexport function setScrollFromStartingEdge(el: HTMLElement, val: number) {\n  let computedStyles = window.getComputedStyle(el) // TODO: pass in isRtl?\n\n  if (computedStyles.direction === 'rtl') {\n    switch (getRtlScrollSystem()) {\n      case 'positive':\n        val = (el.scrollWidth - el.clientWidth) + val // maxScrollDistance + val\n        break\n      case 'reverse':\n        val = -val\n        break\n    }\n  }\n\n  el.scrollLeft = val\n}\n\n// Horizontal Scroll System Detection\n// ----------------------------------------------------------------------------------------------\n\nlet _rtlScrollSystem\n\nfunction getRtlScrollSystem() {\n  return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem())\n}\n\nfunction detectRtlScrollSystem() {\n  let el = document.createElement('div')\n  el.style.position = 'absolute'\n  el.style.top = '-1000px'\n  el.style.width = '1px'\n  el.style.height = '1px'\n  el.style.overflow = 'scroll'\n  el.style.direction = 'rtl'\n  el.style.fontSize = '100px'\n  el.innerHTML = 'A'\n\n  document.body.appendChild(el)\n\n  let system\n  if (el.scrollLeft > 0) {\n    system = 'positive' // scroll is a positive number from the left edge\n  } else {\n    el.scrollLeft = 1\n    if (el.scrollLeft > 0) {\n      system = 'reverse' // scroll is a positive number from the right edge\n    } else {\n      system = 'negative' // scroll is a negative number from the right edge\n    }\n  }\n\n  removeElement(el)\n  return system\n}\n","import {\n  applyStyle,\n  translateRect, Rect, Point,\n  findElements,\n  computeInnerRect,\n  CssDimValue,\n  removeElement,\n} from '@fullcalendar/common'\nimport { ScrollListener } from './ScrollListener'\nimport { getScrollCanvasOrigin, getScrollFromLeftEdge } from './scroll-left-norm'\n\ninterface ElementGeom {\n  parentBound: Rect // relative to the canvas origin\n  naturalBound: Rect | null // of the el itself\n  elWidth: number\n  elHeight: number\n  textAlign: string\n}\n\nconst IS_MS_EDGE = /Edge/.test(navigator.userAgent) // TODO: what about Chromeum-based Edge?\nconst STICKY_SELECTOR = '.fc-sticky'\n\n/*\nuseful beyond the native position:sticky for these reasons:\n- support in IE11\n- nice centering support\n\nREQUIREMENT: fc-sticky elements, if the fc-sticky className is taken away, should NOT have relative or absolute positioning.\nThis is because we attach the coords with JS, and the VDOM might take away the fc-sticky class but doesn't know kill the positioning.\n\nTODO: don't query text-align:center. isn't compatible with flexbox centering. instead, check natural X coord within parent container\n*/\nexport class StickyScrolling {\n  listener?: ScrollListener\n  usingRelative: boolean | null = null\n\n  constructor(\n    private scrollEl: HTMLElement,\n    private isRtl: boolean,\n  ) {\n    this.usingRelative =\n      !computeStickyPropVal() || // IE11\n      // https://stackoverflow.com/questions/56835658/in-microsoft-edge-sticky-positioning-doesnt-work-when-combined-with-dir-rtl\n      (IS_MS_EDGE && isRtl)\n\n    if (this.usingRelative) {\n      this.listener = new ScrollListener(scrollEl)\n      this.listener.emitter.on('scrollEnd', this.updateSize)\n    }\n  }\n\n  destroy() {\n    if (this.listener) {\n      this.listener.destroy()\n    }\n  }\n\n  updateSize = () => {\n    let { scrollEl } = this\n    let els = findElements(scrollEl, STICKY_SELECTOR)\n    let elGeoms = this.queryElGeoms(els)\n    let viewportWidth = scrollEl.clientWidth\n    let viewportHeight = scrollEl.clientHeight\n\n    if (this.usingRelative) {\n      let elDestinations = this.computeElDestinations(elGeoms, viewportWidth) // read before prepPositioning\n\n      assignRelativePositions(els, elGeoms, elDestinations, viewportWidth, viewportHeight)\n    } else {\n      assignStickyPositions(els, elGeoms, viewportWidth)\n    }\n  }\n\n  queryElGeoms(els: HTMLElement[]): ElementGeom[] {\n    let { scrollEl, isRtl } = this\n    let canvasOrigin = getScrollCanvasOrigin(scrollEl)\n    let elGeoms: ElementGeom[] = []\n\n    for (let el of els) {\n      let parentBound = translateRect(\n        computeInnerRect(el.parentNode as HTMLElement, true, true), // weird way to call this!!!\n        -canvasOrigin.left,\n        -canvasOrigin.top,\n      )\n\n      let elRect = el.getBoundingClientRect()\n      let computedStyles = window.getComputedStyle(el)\n      let textAlign = window.getComputedStyle(el.parentNode as HTMLElement).textAlign // ask the parent\n      let naturalBound = null\n\n      if (textAlign === 'start') {\n        textAlign = isRtl ? 'right' : 'left'\n      } else if (textAlign === 'end') {\n        textAlign = isRtl ? 'left' : 'right'\n      }\n\n      if (computedStyles.position !== 'sticky') {\n        naturalBound = translateRect(\n          elRect,\n          -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n          -canvasOrigin.top - (parseFloat(computedStyles.top) || 0),\n        )\n      }\n\n      elGeoms.push({\n        parentBound,\n        naturalBound,\n        elWidth: elRect.width,\n        elHeight: elRect.height,\n        textAlign,\n      })\n    }\n\n    return elGeoms\n  }\n\n  // only for IE\n  computeElDestinations(elGeoms: ElementGeom[], viewportWidth: number): Point[] {\n    let { scrollEl } = this\n    let viewportTop = scrollEl.scrollTop\n    let viewportLeft = getScrollFromLeftEdge(scrollEl)\n    let viewportRight = viewportLeft + viewportWidth\n\n    return elGeoms.map((elGeom) => {\n      let { elWidth, elHeight, parentBound, naturalBound } = elGeom\n      let destLeft // relative to canvas topleft\n      let destTop // \"\n\n      switch (elGeom.textAlign) {\n        case 'left':\n          destLeft = viewportLeft\n          break\n        case 'right':\n          destLeft = viewportRight - elWidth\n          break\n        case 'center':\n          destLeft = (viewportLeft + viewportRight) / 2 - elWidth / 2 /// noooo, use half-width insteadddddddd\n          break\n      }\n\n      destLeft = Math.min(destLeft, parentBound.right - elWidth)\n      destLeft = Math.max(destLeft, parentBound.left)\n\n      destTop = viewportTop\n      destTop = Math.min(destTop, parentBound.bottom - elHeight)\n      destTop = Math.max(destTop, naturalBound.top) // better to use natural top for upper bound\n\n      return { left: destLeft, top: destTop }\n    })\n  }\n}\n\nfunction assignRelativePositions(\n  els: HTMLElement[],\n  elGeoms: ElementGeom[],\n  elDestinations: Point[],\n  viewportWidth: number,\n  viewportHeight: number,\n) {\n  els.forEach((el, i) => {\n    let { naturalBound, parentBound } = elGeoms[i]\n    let parentWidth = parentBound.right - parentBound.left\n    let parentHeight = parentBound.bottom - parentBound.bottom\n    let left: CssDimValue\n    let top: CssDimValue\n\n    if (\n      parentWidth > viewportWidth ||\n      parentHeight > viewportHeight\n    ) {\n      left = elDestinations[i].left - naturalBound.left\n      top = elDestinations[i].top - naturalBound.top\n    } else { // if parent container can be completely in view, we don't need stickiness\n      left = ''\n      top = ''\n    }\n\n    applyStyle(el, {\n      position: 'relative',\n      left,\n      right: -left, // for rtl\n      top,\n    })\n  })\n}\n\nfunction assignStickyPositions(els: HTMLElement[], elGeoms: ElementGeom[], viewportWidth: number) {\n  els.forEach((el, i) => {\n    let { textAlign, elWidth, parentBound } = elGeoms[i]\n    let parentWidth = parentBound.right - parentBound.left\n    let left: CssDimValue\n\n    if (\n      textAlign === 'center' &&\n      parentWidth > viewportWidth\n    ) {\n      left = (viewportWidth - elWidth) / 2\n    } else { // if parent container can be completely in view, we don't need stickiness\n      left = ''\n    }\n\n    applyStyle(el, { // will already have fc-sticky class which makes it sticky\n      left,\n      right: left, // for when centered\n      top: 0,\n    })\n  })\n}\n\n// overkill now that we use the stylesheet to set it!\n// just test that the 'position' value of a div with the fc-sticky classname has the word 'sticky' in it\nfunction computeStickyPropVal() {\n  let el = document.createElement('div')\n  el.className = 'fc-sticky'\n  document.body.appendChild(el)\n  let val = window.getComputedStyle(el).position\n  removeElement(el)\n\n  if (val.indexOf('sticky') !== -1) {\n    return val\n  }\n\n  return null\n}\n","import {\n  createElement, ComponentChildren, createRef, Ref, BaseComponent, setRef,\n  ScrollerLike,\n  Scroller, OverflowValue,\n  getScrollbarWidths,\n  getIsRtlScrollbarOnLeft,\n  isPropsEqual,\n} from '@fullcalendar/common'\n\nexport type ClippedOverflowValue = OverflowValue | 'scroll-hidden'\n\nexport interface ClippedScrollerProps {\n  overflowX: ClippedOverflowValue\n  overflowY: ClippedOverflowValue\n  liquid: boolean\n  maxHeight?: number // incompatible with liquid\n  children?: ComponentChildren\n  scrollerRef?: Ref<Scroller>\n  scrollerElRef?: Ref<HTMLElement>\n}\n\ninterface ClippedScrollerState {\n  yScrollbarWidth?: number\n  xScrollbarWidth?: number\n}\n\nexport class ClippedScroller extends BaseComponent<ClippedScrollerProps, ClippedScrollerState> implements ScrollerLike {\n  private elRef = createRef<HTMLDivElement>()\n  private scroller: Scroller\n\n  state = { // HACK?\n    xScrollbarWidth: getScrollbarWidths().x,\n    yScrollbarWidth: getScrollbarWidths().y,\n  }\n\n  render() {\n    let { props, state, context } = this\n    let isScrollbarOnLeft = context.isRtl && getIsRtlScrollbarOnLeft()\n    let overcomeLeft = 0\n    let overcomeRight = 0\n    let overcomeBottom = 0\n\n    if (props.overflowX === 'scroll-hidden') {\n      overcomeBottom = state.xScrollbarWidth\n    }\n\n    if (props.overflowY === 'scroll-hidden') {\n      if (state.yScrollbarWidth != null) {\n        if (isScrollbarOnLeft) {\n          overcomeLeft = state.yScrollbarWidth\n        } else {\n          overcomeRight = state.yScrollbarWidth\n        }\n      }\n    }\n\n    return (\n      <div\n        ref={this.elRef}\n        className={'fc-scroller-harness' + (props.liquid ? ' fc-scroller-harness-liquid' : '')}\n      >\n        <Scroller\n          ref={this.handleScroller}\n          elRef={this.props.scrollerElRef}\n          overflowX={props.overflowX === 'scroll-hidden' ? 'scroll' : props.overflowX}\n          overflowY={props.overflowY === 'scroll-hidden' ? 'scroll' : props.overflowY}\n          overcomeLeft={overcomeLeft}\n          overcomeRight={overcomeRight}\n          overcomeBottom={overcomeBottom}\n          maxHeight={\n            typeof props.maxHeight === 'number'\n              ? (props.maxHeight + (props.overflowX === 'scroll-hidden' ? state.xScrollbarWidth : 0))\n              : ''\n          }\n          liquid={props.liquid}\n          liquidIsAbsolute\n        >\n          {props.children}\n        </Scroller>\n      </div>\n    )\n  }\n\n  handleScroller = (scroller: Scroller) => {\n    this.scroller = scroller\n    setRef(this.props.scrollerRef, scroller)\n  }\n\n  componentDidMount() {\n    this.handleSizing()\n    this.context.addResizeHandler(this.handleSizing)\n  }\n\n  componentDidUpdate(prevProps: ClippedScrollerProps) {\n    if (!isPropsEqual(prevProps, this.props)) { // an external change?\n      this.handleSizing()\n    }\n  }\n\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing)\n  }\n\n  handleSizing = () => {\n    let { props } = this\n\n    if (props.overflowY === 'scroll-hidden') {\n      this.setState({ yScrollbarWidth: this.scroller.getYScrollbarWidth() })\n    }\n\n    if (props.overflowX === 'scroll-hidden') {\n      this.setState({ xScrollbarWidth: this.scroller.getXScrollbarWidth() })\n    }\n  }\n\n  needsXScrolling() {\n    return this.scroller.needsXScrolling()\n  }\n\n  needsYScrolling() {\n    return this.scroller.needsYScrolling()\n  }\n}\n","import { ScrollListener } from './ScrollListener'\nimport { setScrollFromStartingEdge } from './scroll-left-norm'\n\nexport class ScrollSyncer {\n  private masterEl: HTMLElement\n  private scrollListeners: ScrollListener[]\n  private isPaused: boolean = false\n\n  constructor(\n    private isVertical: boolean,\n    private scrollEls: HTMLElement[],\n  ) {\n    this.scrollListeners = scrollEls.map((el) => this.bindScroller(el))\n  }\n\n  destroy() {\n    for (let scrollListener of this.scrollListeners) {\n      scrollListener.destroy()\n    }\n  }\n\n  bindScroller(el: HTMLElement) {\n    let { scrollEls, isVertical } = this\n    let scrollListener = new ScrollListener(el)\n\n    const onScroll = (isWheel, isTouch) => {\n      if (!this.isPaused) {\n        if (!this.masterEl || (this.masterEl !== el && (isWheel || isTouch))) {\n          this.assignMaster(el)\n        }\n\n        if (this.masterEl === el) { // dealing with current\n          for (let otherEl of scrollEls) {\n            if (otherEl !== el) {\n              if (isVertical) {\n                otherEl.scrollTop = el.scrollTop\n              } else {\n                otherEl.scrollLeft = el.scrollLeft\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const onScrollEnd = () => {\n      if (this.masterEl === el) {\n        this.masterEl = null\n      }\n    }\n\n    scrollListener.emitter.on('scroll', onScroll)\n    scrollListener.emitter.on('scrollEnd', onScrollEnd)\n\n    return scrollListener\n  }\n\n  assignMaster(el: HTMLElement) {\n    this.masterEl = el\n\n    for (let scrollListener of this.scrollListeners) {\n      if (scrollListener.el !== el) {\n        scrollListener.endScroll() // to prevent residual scrolls from reclaiming master\n      }\n    }\n  }\n\n  /*\n  will normalize the scrollLeft value\n  */\n  forceScrollLeft(scrollLeft: number) {\n    this.isPaused = true\n\n    for (let listener of this.scrollListeners) {\n      setScrollFromStartingEdge(listener.el, scrollLeft)\n    }\n\n    this.isPaused = false\n  }\n\n  forceScrollTop(top: number) {\n    this.isPaused = true\n\n    for (let listener of this.scrollListeners) {\n      listener.el.scrollTop = top\n    }\n\n    this.isPaused = false\n  }\n}\n","import {\n  createElement, VNode, Fragment,\n  BaseComponent,\n  isArraysEqual,\n  findElements,\n  mapHash,\n  RefMap,\n  ColProps, CssDimValue, hasShrinkWidth, renderMicroColGroup,\n  ScrollGridProps, ScrollGridSectionConfig, ColGroupConfig,\n  getScrollGridClassNames, getSectionClassNames, getSectionHasLiquidHeight, getAllowYScrolling, renderChunkContent, computeShrinkWidth,\n  getIsRtlScrollbarOnLeft,\n  setRef,\n  sanitizeShrinkWidth,\n  isPropsEqual,\n  compareObjs,\n  isColPropsEqual,\n  getScrollbarWidths,\n  memoizeArraylike,\n  collectFromHash,\n  memoizeHashlike,\n  ScrollGridChunkConfig,\n  getCanVGrowWithinCell,\n} from '@fullcalendar/common'\nimport { StickyScrolling } from './StickyScrolling'\nimport { ClippedScroller, ClippedOverflowValue } from './ClippedScroller'\nimport { ScrollSyncer } from './ScrollSyncer'\n\ninterface ScrollGridState {\n  shrinkWidths: number[] // for only one col within each vertical stack of chunks\n  forceYScrollbars: boolean // null means not computed yet\n  forceXScrollbars: boolean // \"\n  scrollerClientWidths: { [index: string]: number } // why not use array?\n  scrollerClientHeights: { [index: string]: number }\n  sectionRowMaxHeights: number[][][]\n}\n\ninterface ColGroupStat {\n  hasShrinkCol: boolean\n  totalColWidth: number\n  totalColMinWidth: number\n  allowXScrolling: boolean\n  width?: CssDimValue\n  cols: ColProps[]\n}\n\nexport class ScrollGrid extends BaseComponent<ScrollGridProps, ScrollGridState> { // TODO: make <ScrollGridSection> subcomponent\n  private compileColGroupStats = memoizeArraylike(compileColGroupStat, isColGroupStatsEqual)\n  private renderMicroColGroups = memoizeArraylike(renderMicroColGroup) // yucky to memoize VNodes, but much more efficient for consumers\n  private clippedScrollerRefs = new RefMap<ClippedScroller>()\n\n  // doesn't hold non-scrolling els used just for padding\n  private scrollerElRefs = new RefMap<HTMLElement>(this._handleScrollerEl.bind(this))\n\n  private chunkElRefs = new RefMap<HTMLTableCellElement>(this._handleChunkEl.bind(this))\n  private getStickyScrolling = memoizeArraylike(initStickyScrolling, null, destroyStickyScrolling)\n  private getScrollSyncersBySection = memoizeHashlike(initScrollSyncer.bind(this, true), null, destroyScrollSyncer)\n  private getScrollSyncersByColumn = memoizeHashlike(initScrollSyncer.bind(this, false), null, destroyScrollSyncer)\n  private stickyScrollings: StickyScrolling[] = []\n  private scrollSyncersBySection: { [sectionI: string]: ScrollSyncer } = {}\n  private scrollSyncersByColumn: { [columnI: string]: ScrollSyncer } = {}\n\n  // for row-height-syncing\n  private rowUnstableMap = new Map<HTMLTableRowElement, boolean>() // no need to groom. always self-cancels\n  private rowInnerMaxHeightMap = new Map<HTMLTableRowElement, number>()\n  private anyRowHeightsChanged = false\n\n  state: ScrollGridState = {\n    shrinkWidths: [],\n    forceYScrollbars: false,\n    forceXScrollbars: false,\n    scrollerClientWidths: {},\n    scrollerClientHeights: {},\n    sectionRowMaxHeights: [],\n  }\n\n  render(): VNode {\n    let { props, state, context } = this\n    let { shrinkWidths } = state\n\n    let colGroupStats = this.compileColGroupStats(props.colGroups.map((colGroup) => [colGroup]))\n    let microColGroupNodes = this.renderMicroColGroups(colGroupStats.map((stat, i) => [stat.cols, shrinkWidths[i]]))\n    let classNames = getScrollGridClassNames(props.liquid, context)\n\n    // yuck\n    let indices: [ number, number ][] = []\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        indices.push([sectionI, chunkI])\n      }\n    }\n\n    // TODO: make DRY\n    let sectionConfigs = props.sections\n    let configCnt = sectionConfigs.length\n    let configI = 0\n    let currentConfig: ScrollGridSectionConfig\n    let headSectionNodes: VNode[] = []\n    let bodySectionNodes: VNode[] = []\n    let footSectionNodes: VNode[] = []\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights))\n      configI += 1\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights))\n      configI += 1\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, configI, colGroupStats, microColGroupNodes, state.sectionRowMaxHeights))\n      configI += 1\n    }\n\n    let isBuggy = !getCanVGrowWithinCell() // see NOTE in SimpleScrollGrid\n\n    return createElement(\n      'table',\n      {\n        ref: props.elRef,\n        className: classNames.join(' '),\n      },\n      renderMacroColGroup(colGroupStats, shrinkWidths),\n      Boolean(!isBuggy && headSectionNodes.length) && createElement('thead', {}, ...headSectionNodes),\n      Boolean(!isBuggy && bodySectionNodes.length) && createElement('tbody', {}, ...bodySectionNodes),\n      Boolean(!isBuggy && footSectionNodes.length) && createElement('tfoot', {}, ...footSectionNodes),\n      isBuggy && createElement('tbody', {}, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes),\n    )\n  }\n\n  renderSection(\n    sectionConfig: ScrollGridSectionConfig,\n    sectionIndex: number,\n    colGroupStats: ColGroupStat[],\n    microColGroupNodes: VNode[],\n    sectionRowMaxHeights: number[][][],\n  ): VNode {\n    if ('outerContent' in sectionConfig) {\n      return (\n        <Fragment key={sectionConfig.key}>\n          {sectionConfig.outerContent}\n        </Fragment>\n      )\n    }\n\n    return (\n      <tr key={sectionConfig.key} className={getSectionClassNames(sectionConfig, this.props.liquid).join(' ')}>\n        {sectionConfig.chunks.map((chunkConfig, i) => this.renderChunk(\n          sectionConfig,\n          sectionIndex,\n          colGroupStats[i],\n          microColGroupNodes[i],\n          chunkConfig,\n          i,\n          (sectionRowMaxHeights[sectionIndex] || [])[i] || [],\n        ))}\n      </tr>\n    )\n  }\n\n  renderChunk(\n    sectionConfig: ScrollGridSectionConfig,\n    sectionIndex: number,\n    colGroupStat: ColGroupStat | undefined,\n    microColGroupNode: VNode | undefined,\n    chunkConfig: ScrollGridChunkConfig,\n    chunkIndex: number,\n    rowHeights: number[],\n  ): VNode {\n    if ('outerContent' in chunkConfig) {\n      return (\n        <Fragment key={chunkConfig.key}>\n          {chunkConfig.outerContent}\n        </Fragment>\n      )\n    }\n\n    let { state } = this\n    let { scrollerClientWidths, scrollerClientHeights } = state\n\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let index = sectionIndex * chunksPerSection + chunkIndex\n    let sideScrollIndex = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0\n    let isVScrollSide = chunkIndex === sideScrollIndex\n    let isLastSection = sectionIndex === sectionCnt - 1\n\n    let forceXScrollbars = isLastSection && state.forceXScrollbars // NOOOO can result in `null`\n    let forceYScrollbars = isVScrollSide && state.forceYScrollbars // NOOOO can result in `null`\n\n    let allowXScrolling = colGroupStat && colGroupStat.allowXScrolling // rename?\n    let allowYScrolling = getAllowYScrolling(this.props, sectionConfig) // rename? do in section func?\n\n    let chunkVGrow = getSectionHasLiquidHeight(this.props, sectionConfig) // do in section func?\n    let expandRows = sectionConfig.expandRows && chunkVGrow\n    let tableMinWidth = (colGroupStat && colGroupStat.totalColMinWidth) || ''\n\n    let content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth,\n      clientWidth: scrollerClientWidths[index] !== undefined ? scrollerClientWidths[index] : null,\n      clientHeight: scrollerClientHeights[index] !== undefined ? scrollerClientHeights[index] : null,\n      expandRows,\n      syncRowHeights: Boolean(sectionConfig.syncRowHeights),\n      rowSyncHeights: rowHeights,\n      reportRowHeightChange: this.handleRowHeightChange,\n    })\n\n    let overflowX: ClippedOverflowValue =\n      forceXScrollbars ? (isLastSection ? 'scroll' : 'scroll-hidden') :\n        !allowXScrolling ? 'hidden' :\n          (isLastSection ? 'auto' : 'scroll-hidden')\n\n    let overflowY: ClippedOverflowValue =\n      forceYScrollbars ? (isVScrollSide ? 'scroll' : 'scroll-hidden') :\n        !allowYScrolling ? 'hidden' :\n          (isVScrollSide ? 'auto' : 'scroll-hidden')\n\n    // it *could* be possible to reduce DOM wrappers by only doing a ClippedScroller when allowXScrolling or allowYScrolling,\n    // but if these values were to change, the inner components would be unmounted/remounted because of the parent change.\n    content = (\n      <ClippedScroller\n        ref={this.clippedScrollerRefs.createRef(index)}\n        scrollerElRef={this.scrollerElRefs.createRef(index)}\n        overflowX={overflowX}\n        overflowY={overflowY}\n        liquid={chunkVGrow}\n        maxHeight={sectionConfig.maxHeight}\n      >\n        {content}\n      </ClippedScroller>\n    )\n\n    return (\n      <td key={chunkConfig.key} ref={this.chunkElRefs.createRef(index)}>\n        {content}\n      </td>\n    )\n  }\n\n  componentDidMount() {\n    this.updateScrollSyncers()\n    this.handleSizing(false)\n\n    this.context.addResizeHandler(this.handleSizing)\n  }\n\n  componentDidUpdate(prevProps: ScrollGridProps, prevState: ScrollGridState) {\n    this.updateScrollSyncers()\n\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing(false, prevState.sectionRowMaxHeights !== this.state.sectionRowMaxHeights)\n  }\n\n  componentWillUnmount() {\n    this.context.removeResizeHandler(this.handleSizing)\n\n    this.destroyStickyScrolling()\n    this.destroyScrollSyncers()\n  }\n\n  handleSizing = (isForcedResize: boolean, sectionRowMaxHeightsChanged?: boolean) => {\n    if (!sectionRowMaxHeightsChanged) { // something else changed, probably external\n      this.anyRowHeightsChanged = true\n    }\n\n    let otherState: Partial<ScrollGridState> = {}\n\n    // if reacting to self-change of sectionRowMaxHeightsChanged, or not stable, don't do anything\n    if (isForcedResize || (!sectionRowMaxHeightsChanged && !this.rowUnstableMap.size)) {\n      otherState.sectionRowMaxHeights = this.computeSectionRowMaxHeights()\n    }\n\n    this.setState({\n      shrinkWidths: this.computeShrinkWidths(),\n      ...this.computeScrollerDims(),\n      ...(otherState as any), // wtf\n    }, () => {\n      if (!this.rowUnstableMap.size) {\n        this.updateStickyScrolling() // needs to happen AFTER final positioning committed to DOM\n      }\n    })\n  }\n\n  handleRowHeightChange = (rowEl: HTMLTableRowElement, isStable: boolean) => {\n    let { rowUnstableMap, rowInnerMaxHeightMap } = this\n\n    if (!isStable) {\n      rowUnstableMap.set(rowEl, true)\n    } else {\n      rowUnstableMap.delete(rowEl)\n\n      let innerMaxHeight = getRowInnerMaxHeight(rowEl)\n      if (!rowInnerMaxHeightMap.has(rowEl) || rowInnerMaxHeightMap.get(rowEl) !== innerMaxHeight) {\n        rowInnerMaxHeightMap.set(rowEl, innerMaxHeight)\n        this.anyRowHeightsChanged = true\n      }\n\n      if (!rowUnstableMap.size && this.anyRowHeightsChanged) {\n        this.anyRowHeightsChanged = false\n        this.setState({\n          sectionRowMaxHeights: this.computeSectionRowMaxHeights(),\n        })\n      }\n    }\n  }\n\n  computeShrinkWidths() {\n    let colGroupStats = this.compileColGroupStats(this.props.colGroups.map((colGroup) => [colGroup]))\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let cnt = sectionCnt * chunksPerSection\n    let shrinkWidths: number[] = []\n\n    colGroupStats.forEach((colGroupStat, i) => {\n      if (colGroupStat.hasShrinkCol) {\n        let chunkEls = this.chunkElRefs.collect(i, cnt, chunksPerSection) // in one col\n        shrinkWidths[i] = computeShrinkWidth(chunkEls)\n      }\n    })\n\n    return shrinkWidths\n  }\n\n  // has the side effect of grooming rowInnerMaxHeightMap\n  // TODO: somehow short-circuit if there are no new height changes\n  private computeSectionRowMaxHeights() {\n    let newHeightMap = new Map<HTMLTableRowElement, number>()\n\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let sectionRowMaxHeights: number[][][] = []\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      let sectionConfig = this.props.sections[sectionI]\n      let assignableHeights: number[][] = [] // chunk, row\n\n      if (sectionConfig && sectionConfig.syncRowHeights) {\n        let rowHeightsByChunk: number[][] = []\n\n        for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n          let index = sectionI * chunksPerSection + chunkI\n          let rowHeights: number[] = []\n\n          let chunkEl = this.chunkElRefs.currentMap[index]\n          if (chunkEl) {\n            rowHeights = findElements(chunkEl, '.fc-scrollgrid-sync-table tr').map((rowEl: HTMLTableRowElement) => {\n              let max = getRowInnerMaxHeight(rowEl)\n              newHeightMap.set(rowEl, max)\n              return max\n            })\n          } else {\n            rowHeights = []\n          }\n\n          rowHeightsByChunk.push(rowHeights)\n        }\n\n        let rowCnt = rowHeightsByChunk[0].length\n        let isEqualRowCnt = true\n\n        for (let chunkI = 1; chunkI < chunksPerSection; chunkI += 1) {\n          let isOuterContent = sectionConfig.chunks[chunkI] && sectionConfig.chunks[chunkI].outerContent !== undefined // can be null\n\n          if (!isOuterContent && rowHeightsByChunk[chunkI].length !== rowCnt) { // skip outer content\n            isEqualRowCnt = false\n            break\n          }\n        }\n\n        if (!isEqualRowCnt) {\n          let chunkHeightSums: number[] = []\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            chunkHeightSums.push(\n              sumNumbers(rowHeightsByChunk[chunkI]) + rowHeightsByChunk[chunkI].length, // add in border\n            )\n          }\n\n          let maxTotalSum = Math.max(...chunkHeightSums)\n\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            let rowInChunkCnt = rowHeightsByChunk[chunkI].length\n            let rowInChunkTotalHeight = maxTotalSum - rowInChunkCnt // subtract border\n\n            // height of non-first row. we do this to avoid rounding, because it's unreliable within a table\n            let rowInChunkHeightOthers = Math.floor(rowInChunkTotalHeight / rowInChunkCnt)\n\n            // whatever is leftover goes to the first row\n            let rowInChunkHeightFirst = rowInChunkTotalHeight - rowInChunkHeightOthers * (rowInChunkCnt - 1)\n\n            let rowInChunkHeights: number[] = []\n            let row = 0\n\n            if (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightFirst)\n              row += 1\n            }\n\n            while (row < rowInChunkCnt) {\n              rowInChunkHeights.push(rowInChunkHeightOthers)\n              row += 1\n            }\n\n            assignableHeights.push(rowInChunkHeights)\n          }\n        } else {\n          for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n            assignableHeights.push([])\n          }\n\n          for (let row = 0; row < rowCnt; row += 1) {\n            let rowHeightsAcrossChunks: number[] = []\n\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              let h = rowHeightsByChunk[chunkI][row]\n              if (h != null) { // protect against outerContent\n                rowHeightsAcrossChunks.push(h)\n              }\n            }\n\n            let maxHeight = Math.max(...rowHeightsAcrossChunks)\n\n            for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n              assignableHeights[chunkI].push(maxHeight)\n            }\n          }\n        }\n      }\n\n      sectionRowMaxHeights.push(assignableHeights)\n    }\n\n    this.rowInnerMaxHeightMap = newHeightMap\n\n    return sectionRowMaxHeights\n  }\n\n  computeScrollerDims() {\n    let scrollbarWidth = getScrollbarWidths()\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let sideScrollI = (!this.context.isRtl || getIsRtlScrollbarOnLeft()) ? chunksPerSection - 1 : 0\n    let lastSectionI = sectionCnt - 1\n    let currentScrollers = this.clippedScrollerRefs.currentMap\n    let scrollerEls = this.scrollerElRefs.currentMap\n    let forceYScrollbars = false\n    let forceXScrollbars = false\n    let scrollerClientWidths: { [index: string]: number } = {}\n    let scrollerClientHeights: { [index: string]: number } = {}\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n      let index = sectionI * chunksPerSection + sideScrollI\n      let scroller = currentScrollers[index]\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true\n        break\n      }\n    }\n\n    for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) { // along last row\n      let index = lastSectionI * chunksPerSection + chunkI\n      let scroller = currentScrollers[index]\n\n      if (scroller && scroller.needsXScrolling()) {\n        forceXScrollbars = true\n        break\n      }\n    }\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      for (let chunkI = 0; chunkI < chunksPerSection; chunkI += 1) {\n        let index = sectionI * chunksPerSection + chunkI\n        let scrollerEl = scrollerEls[index]\n\n        if (scrollerEl) {\n          // TODO: weird way to get this. need harness b/c doesn't include table borders\n          let harnessEl = scrollerEl.parentNode as HTMLElement\n\n          scrollerClientWidths[index] = Math.floor(\n            harnessEl.getBoundingClientRect().width - (\n              (chunkI === sideScrollI && forceYScrollbars)\n                ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                : 0\n            ),\n          )\n\n          scrollerClientHeights[index] = Math.floor(\n            harnessEl.getBoundingClientRect().height - (\n              (sectionI === lastSectionI && forceXScrollbars)\n                ? scrollbarWidth.x // use global because scroller might not have scrollbars yet but will need them in future\n                : 0\n            ),\n          )\n        }\n      }\n    }\n\n    return { forceYScrollbars, forceXScrollbars, scrollerClientWidths, scrollerClientHeights }\n  }\n\n  updateStickyScrolling() {\n    let { isRtl } = this.context\n    let argsByKey = this.scrollerElRefs.getAll().map(\n      (scrollEl) => [scrollEl, isRtl] as [ HTMLElement, boolean ],\n    )\n\n    let stickyScrollings = this.getStickyScrolling(argsByKey)\n\n    stickyScrollings.forEach((stickyScrolling) => stickyScrolling.updateSize())\n\n    this.stickyScrollings = stickyScrollings\n  }\n\n  destroyStickyScrolling() {\n    this.stickyScrollings.forEach(destroyStickyScrolling)\n  }\n\n  updateScrollSyncers() {\n    let [sectionCnt, chunksPerSection] = this.getDims()\n    let cnt = sectionCnt * chunksPerSection\n    let scrollElsBySection: { [sectionI: string]: HTMLElement[] } = {}\n    let scrollElsByColumn: { [colI: string]: HTMLElement[] } = {}\n    let scrollElMap = this.scrollerElRefs.currentMap\n\n    for (let sectionI = 0; sectionI < sectionCnt; sectionI += 1) {\n      let startIndex = sectionI * chunksPerSection\n      let endIndex = startIndex + chunksPerSection\n\n      scrollElsBySection[sectionI] = collectFromHash(scrollElMap, startIndex, endIndex, 1) // use the filtered\n    }\n\n    for (let col = 0; col < chunksPerSection; col += 1) {\n      scrollElsByColumn[col] = this.scrollerElRefs.collect(col, cnt, chunksPerSection) // DON'T use the filtered\n    }\n\n    this.scrollSyncersBySection = this.getScrollSyncersBySection(scrollElsBySection)\n    this.scrollSyncersByColumn = this.getScrollSyncersByColumn(scrollElsByColumn)\n  }\n\n  destroyScrollSyncers() {\n    mapHash(this.scrollSyncersBySection, destroyScrollSyncer)\n    mapHash(this.scrollSyncersByColumn, destroyScrollSyncer)\n  }\n\n  getChunkConfigByIndex(index: number) { // somewhat expensive for something so simple\n    let chunksPerSection = this.getDims()[1]\n    let sectionI = Math.floor(index / chunksPerSection)\n    let chunkI = index % chunksPerSection\n    let sectionConfig = this.props.sections[sectionI]\n\n    return sectionConfig && sectionConfig.chunks[chunkI]\n  }\n\n  forceScrollLeft(col: number, scrollLeft: number) {\n    let scrollSyncer = this.scrollSyncersByColumn[col]\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollLeft(scrollLeft)\n    }\n  }\n\n  forceScrollTop(sectionI: number, scrollTop: number) {\n    let scrollSyncer = this.scrollSyncersBySection[sectionI]\n\n    if (scrollSyncer) {\n      scrollSyncer.forceScrollTop(scrollTop)\n    }\n  }\n\n  _handleChunkEl(chunkEl: HTMLTableCellElement | null, key: string) {\n    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10))\n\n    if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.elRef, chunkEl)\n    }\n  }\n\n  _handleScrollerEl(scrollerEl: HTMLElement | null, key: string) {\n    let chunkConfig = this.getChunkConfigByIndex(parseInt(key, 10))\n\n    if (chunkConfig) { // null if section disappeared. bad, b/c won't null-set the elRef\n      setRef(chunkConfig.scrollerElRef, scrollerEl)\n    }\n  }\n\n  getDims() {\n    let sectionCnt = this.props.sections.length\n    let chunksPerSection = sectionCnt ? this.props.sections[0].chunks.length : 0\n\n    return [sectionCnt, chunksPerSection]\n  }\n}\n\nScrollGrid.addStateEquality({\n  shrinkWidths: isArraysEqual,\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual,\n})\n\nfunction sumNumbers(numbers: number[]) { // TODO: general util\n  let sum = 0\n\n  for (let n of numbers) {\n    sum += n\n  }\n\n  return sum\n}\n\nfunction getRowInnerMaxHeight(rowEl: HTMLElement) {\n  let innerHeights = findElements(rowEl, '.fc-scrollgrid-sync-inner').map(getElHeight)\n\n  if (innerHeights.length) {\n    return Math.max(...innerHeights)\n  }\n\n  return 0\n}\n\nfunction getElHeight(el: HTMLElement) {\n  return el.offsetHeight // better to deal with integers, for rounding, for PureComponent\n}\n\nfunction renderMacroColGroup(colGroupStats: ColGroupStat[], shrinkWidths: number[]) {\n  let children = colGroupStats.map((colGroupStat, i) => {\n    let width = colGroupStat.width\n\n    if (width === 'shrink') {\n      width = colGroupStat.totalColWidth + sanitizeShrinkWidth(shrinkWidths[i]) + 1 // +1 for border :(\n    }\n\n    return ( // eslint-disable-next-line react/jsx-key\n      <col style={{ width }} />\n    )\n  })\n\n  return createElement('colgroup', {}, ...children)\n}\n\nfunction compileColGroupStat(colGroupConfig: ColGroupConfig): ColGroupStat {\n  let totalColWidth = sumColProp(colGroupConfig.cols, 'width') // excludes \"shrink\"\n  let totalColMinWidth = sumColProp(colGroupConfig.cols, 'minWidth')\n  let hasShrinkCol = hasShrinkWidth(colGroupConfig.cols)\n  let allowXScrolling = colGroupConfig.width !== 'shrink' && Boolean(totalColWidth || totalColMinWidth || hasShrinkCol)\n\n  return {\n    hasShrinkCol,\n    totalColWidth,\n    totalColMinWidth,\n    allowXScrolling,\n    cols: colGroupConfig.cols,\n    width: colGroupConfig.width,\n  }\n}\n\nfunction sumColProp(cols: ColProps[], propName: string) {\n  let total = 0\n\n  for (let col of cols) {\n    let val = col[propName]\n\n    if (typeof val === 'number') {\n      total += val * (col.span || 1)\n    }\n  }\n\n  return total\n}\n\nconst COL_GROUP_STAT_EQUALITY = {\n  cols: isColPropsEqual,\n}\n\nfunction isColGroupStatsEqual(stat0: ColGroupStat, stat1: ColGroupStat): boolean {\n  return compareObjs(stat0, stat1, COL_GROUP_STAT_EQUALITY)\n}\n\n// for memoizers...\n\nfunction initScrollSyncer(isVertical: boolean, ...scrollEls: HTMLElement[]) {\n  return new ScrollSyncer(isVertical, scrollEls)\n}\n\nfunction destroyScrollSyncer(scrollSyncer: ScrollSyncer) {\n  scrollSyncer.destroy()\n}\n\nfunction initStickyScrolling(scrollEl: HTMLElement, isRtl: boolean) {\n  return new StickyScrolling(scrollEl, isRtl)\n}\n\nfunction destroyStickyScrolling(stickyScrolling: StickyScrolling) {\n  stickyScrolling.destroy()\n}\n","import { createPlugin } from '@fullcalendar/common'\n\nimport premiumCommonPlugin from '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n// ensure ambient declarations\nimport '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n\nimport { ScrollGrid } from './ScrollGrid'\n\nexport { ScrollGrid }\nexport { setScrollFromStartingEdge } from './scroll-left-norm'\n\nexport default createPlugin({\n  deps: [\n    premiumCommonPlugin,\n  ],\n  scrollGridImpl: ScrollGrid,\n})\n"]},"metadata":{},"sourceType":"module"}